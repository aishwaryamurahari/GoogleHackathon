{"ast":null,"code":"export class RouteService {\n  constructor(map) {\n    this.directionsService = void 0;\n    this.placesService = void 0;\n    this.map = void 0;\n    this.photoSpotCache = new Map();\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n  async findPhotoWorthyRoutes(origin, destination) {\n    try {\n      // Get routes for different travel modes in parallel\n      const travelModes = [{\n        mode: google.maps.TravelMode.WALKING,\n        name: 'Walking'\n      }, {\n        mode: google.maps.TravelMode.BICYCLING,\n        name: 'Cycling'\n      }, {\n        mode: google.maps.TravelMode.DRIVING,\n        name: 'Driving'\n      }];\n      const routePromises = travelModes.map(async travelMode => {\n        try {\n          const response = await this.getDirections(origin, destination, travelMode.mode);\n          return response.routes.map((route, index) => ({\n            route,\n            travelMode,\n            index\n          }));\n        } catch (error) {\n          console.warn(`Failed to get ${travelMode.name} routes:`, error);\n          return [];\n        }\n      });\n      const allRouteData = await Promise.all(routePromises);\n      const routes = [];\n\n      // Process all routes in parallel\n      const routeProcessingPromises = allRouteData.flat().map(async ({\n        route,\n        travelMode,\n        index\n      }) => {\n        var _route$legs$0$distanc, _route$legs$0$duratio;\n        const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n        const photoScore = this.calculateEnhancedPhotoScore(photoSpots, route);\n        const adjustedDuration = this.calculateAdjustedDuration(route, photoSpots);\n        return {\n          id: `route-${travelMode.name}-${index}`,\n          name: this.getRouteName(index, route, travelMode.name),\n          distance: ((_route$legs$0$distanc = route.legs[0].distance) === null || _route$legs$0$distanc === void 0 ? void 0 : _route$legs$0$distanc.text) || '',\n          duration: adjustedDuration,\n          photoScore,\n          photoSpots,\n          path: this.extractPathFromRoute(route),\n          travelMode: travelMode.name,\n          baseDuration: ((_route$legs$0$duratio = route.legs[0].duration) === null || _route$legs$0$duratio === void 0 ? void 0 : _route$legs$0$duratio.text) || ''\n        };\n      });\n      const processedRoutes = await Promise.all(routeProcessingPromises);\n      routes.push(...processedRoutes);\n\n      // Sort routes by photo score, then by duration for similar scores\n      return routes.sort((a, b) => {\n        if (Math.abs(a.photoScore - b.photoScore) < 10) {\n          // If photo scores are close, prefer shorter duration\n          return this.parseDuration(a.duration) - this.parseDuration(b.duration);\n        }\n        return b.photoScore - a.photoScore;\n      });\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n  async getDirections(origin, destination, travelMode) {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route({\n        origin,\n        destination,\n        travelMode\n      }, (result, status) => {\n        if (status === google.maps.DirectionsStatus.OK && result) {\n          resolve(result);\n        } else {\n          reject(new Error(`Directions request failed: ${status}`));\n        }\n      });\n    });\n  }\n  async findPhotoSpotsAlongRoute(route) {\n    const path = this.extractPathFromRoute(route);\n\n    // Sample fewer points for better performance\n    const numPoints = Math.min(Math.max(3, Math.floor(path.length / 20)), 8);\n    const samplePoints = this.getSamplePoints(path, numPoints);\n\n    // Search for photo spots in parallel\n    const spotPromises = samplePoints.map(point => this.searchNearbyPhotoSpots(point));\n    const spotsArrays = await Promise.all(spotPromises);\n    const photoSpots = spotsArrays.flat();\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n  async searchNearbyPhotoSpots(location) {\n    const cacheKey = `${location.lat.toFixed(3)},${location.lng.toFixed(3)}`;\n\n    // Check cache first\n    if (this.photoSpotCache.has(cacheKey)) {\n      return this.photoSpotCache.get(cacheKey);\n    }\n    return new Promise(resolve => {\n      this.placesService.nearbySearch({\n        location: new google.maps.LatLng(location.lat, location.lng),\n        radius: 200,\n        type: 'point_of_interest',\n        keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery|monument|statue|bridge|fountain|garden'\n      }, (results, status) => {\n        if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n          const photoSpots = results.filter(place => place.rating && place.rating >= 3.5).map(place => {\n            var _place$photos, _place$photos$, _place$geometry, _place$geometry$locat, _place$geometry2, _place$geometry2$loca, _place$geometry3, _place$geometry3$loca, _place$geometry4, _place$geometry4$loca;\n            return {\n              id: place.place_id || '',\n              name: place.name || '',\n              rating: place.rating || 0,\n              photoUrl: ((_place$photos = place.photos) === null || _place$photos === void 0 ? void 0 : (_place$photos$ = _place$photos[0]) === null || _place$photos$ === void 0 ? void 0 : _place$photos$.getUrl({\n                maxWidth: 150,\n                maxHeight: 100\n              })) || `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n              distance: this.calculateDistance(location, {\n                lat: ((_place$geometry = place.geometry) === null || _place$geometry === void 0 ? void 0 : (_place$geometry$locat = _place$geometry.location) === null || _place$geometry$locat === void 0 ? void 0 : _place$geometry$locat.lat()) || 0,\n                lng: ((_place$geometry2 = place.geometry) === null || _place$geometry2 === void 0 ? void 0 : (_place$geometry2$loca = _place$geometry2.location) === null || _place$geometry2$loca === void 0 ? void 0 : _place$geometry2$loca.lng()) || 0\n              }),\n              location: {\n                lat: ((_place$geometry3 = place.geometry) === null || _place$geometry3 === void 0 ? void 0 : (_place$geometry3$loca = _place$geometry3.location) === null || _place$geometry3$loca === void 0 ? void 0 : _place$geometry3$loca.lat()) || 0,\n                lng: ((_place$geometry4 = place.geometry) === null || _place$geometry4 === void 0 ? void 0 : (_place$geometry4$loca = _place$geometry4.location) === null || _place$geometry4$loca === void 0 ? void 0 : _place$geometry4$loca.lng()) || 0\n              }\n            };\n          });\n\n          // Cache the results\n          this.photoSpotCache.set(cacheKey, photoSpots);\n          resolve(photoSpots);\n        } else {\n          resolve([]);\n        }\n      });\n    });\n  }\n  calculateEnhancedPhotoScore(photoSpots, route) {\n    var _route$legs$0$distanc2;\n    if (photoSpots.length === 0) return 0;\n    const routeDistance = this.parseDistance(((_route$legs$0$distanc2 = route.legs[0].distance) === null || _route$legs$0$distanc2 === void 0 ? void 0 : _route$legs$0$distanc2.text) || '0 km');\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n\n    // Enhanced scoring algorithm\n    const ratingScore = Math.min(40, (avgRating - 3.0) * 20); // 0-40 points\n    const quantityScore = Math.min(30, photoSpots.length * 3); // 0-30 points\n\n    // Density bonus: more spots per km = higher score\n    const spotsPerKm = photoSpots.length / Math.max(routeDistance, 0.1);\n    const densityScore = Math.min(20, spotsPerKm * 5); // 0-20 points\n\n    // Variety bonus: different types of spots\n    const uniqueTypes = new Set(photoSpots.map(spot => this.getSpotType(spot.name))).size;\n    const varietyScore = Math.min(10, uniqueTypes * 2); // 0-10 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore + densityScore + varietyScore)));\n  }\n  calculateAdjustedDuration(route, photoSpots) {\n    var _route$legs$0$duratio2;\n    const baseDuration = this.parseDuration(((_route$legs$0$duratio2 = route.legs[0].duration) === null || _route$legs$0$duratio2 === void 0 ? void 0 : _route$legs$0$duratio2.text) || '0 min');\n\n    // Add time for photo stops (5 minutes per photo spot)\n    const photoStopTime = photoSpots.length * 5;\n    const totalMinutes = baseDuration + photoStopTime;\n    return this.formatDuration(totalMinutes);\n  }\n  parseDuration(durationText) {\n    const match = durationText.match(/(\\d+)\\s*(?:hour|hr|h|minute|min|m)/i);\n    if (!match) return 0;\n    const value = parseInt(match[1]);\n    if (durationText.toLowerCase().includes('hour') || durationText.toLowerCase().includes('hr') || durationText.toLowerCase().includes('h')) {\n      return value * 60;\n    }\n    return value;\n  }\n  parseDistance(distanceText) {\n    const match = distanceText.match(/(\\d+(?:\\.\\d+)?)\\s*(?:km|mi|m)/i);\n    if (!match) return 0;\n    const value = parseFloat(match[1]);\n    if (distanceText.toLowerCase().includes('mi')) {\n      return value * 1.60934; // Convert miles to km\n    }\n    if (distanceText.toLowerCase().includes('m') && !distanceText.toLowerCase().includes('km')) {\n      return value / 1000; // Convert meters to km\n    }\n    return value;\n  }\n  formatDuration(minutes) {\n    if (minutes < 60) {\n      return `${minutes} min`;\n    }\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    if (remainingMinutes === 0) {\n      return `${hours} hour${hours > 1 ? 's' : ''}`;\n    }\n    return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} min`;\n  }\n  getSpotType(name) {\n    const lowerName = name.toLowerCase();\n    if (lowerName.includes('park') || lowerName.includes('garden')) return 'park';\n    if (lowerName.includes('museum') || lowerName.includes('gallery')) return 'museum';\n    if (lowerName.includes('cafe') || lowerName.includes('restaurant')) return 'cafe';\n    if (lowerName.includes('art') || lowerName.includes('mural')) return 'art';\n    if (lowerName.includes('bridge') || lowerName.includes('monument')) return 'landmark';\n    return 'other';\n  }\n  extractPathFromRoute(route) {\n    const path = [];\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({\n              lat: point.lat(),\n              lng: point.lng()\n            });\n          });\n        }\n      });\n    });\n    return path;\n  }\n  getSamplePoints(path, numPoints) {\n    if (path.length <= numPoints) return path;\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints = [];\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n    return samplePoints;\n  }\n  calculateDistance(point1, point2) {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n  deduplicatePhotoSpots(photoSpots) {\n    const seen = new Set();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n  getRouteName(index, route, travelMode) {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    const baseName = names[index] || `Route ${index + 1}`;\n    return `${baseName} (${travelMode})`;\n  }\n\n  // Clear cache when needed\n  clearCache() {\n    this.photoSpotCache.clear();\n  }\n}","map":{"version":3,"names":["RouteService","constructor","map","directionsService","placesService","photoSpotCache","Map","google","maps","DirectionsService","places","PlacesService","findPhotoWorthyRoutes","origin","destination","travelModes","mode","TravelMode","WALKING","name","BICYCLING","DRIVING","routePromises","travelMode","response","getDirections","routes","route","index","error","console","warn","allRouteData","Promise","all","routeProcessingPromises","flat","_route$legs$0$distanc","_route$legs$0$duratio","photoSpots","findPhotoSpotsAlongRoute","photoScore","calculateEnhancedPhotoScore","adjustedDuration","calculateAdjustedDuration","id","getRouteName","distance","legs","text","duration","path","extractPathFromRoute","baseDuration","processedRoutes","push","sort","a","b","Math","abs","parseDuration","resolve","reject","result","status","DirectionsStatus","OK","Error","numPoints","min","max","floor","length","samplePoints","getSamplePoints","spotPromises","point","searchNearbyPhotoSpots","spotsArrays","deduplicatePhotoSpots","rating","location","cacheKey","lat","toFixed","lng","has","get","nearbySearch","LatLng","radius","type","keyword","results","PlacesServiceStatus","filter","place","_place$photos","_place$photos$","_place$geometry","_place$geometry$locat","_place$geometry2","_place$geometry2$loca","_place$geometry3","_place$geometry3$loca","_place$geometry4","_place$geometry4$loca","place_id","photoUrl","photos","getUrl","maxWidth","maxHeight","encodeURIComponent","calculateDistance","geometry","set","_route$legs$0$distanc2","routeDistance","parseDistance","avgRating","reduce","sum","spot","ratingScore","quantityScore","spotsPerKm","densityScore","uniqueTypes","Set","getSpotType","size","varietyScore","round","_route$legs$0$duratio2","photoStopTime","totalMinutes","formatDuration","durationText","match","value","parseInt","toLowerCase","includes","distanceText","parseFloat","minutes","hours","remainingMinutes","lowerName","forEach","leg","steps","step","i","point1","point2","R","dLat","PI","dLng","sin","cos","c","atan2","sqrt","seen","add","names","baseName","clearCache","clear"],"sources":["/Users/aishwaryamurahari/Documents/study/GoogleHackathon/src/services/routeService.ts"],"sourcesContent":["import { Route, PhotoSpot } from '../types';\n\ndeclare global {\n  interface Window {\n    google: typeof google;\n  }\n}\n\nexport class RouteService {\n  private directionsService: google.maps.DirectionsService;\n  private placesService: google.maps.places.PlacesService;\n  private map: google.maps.Map;\n  private photoSpotCache: Map<string, PhotoSpot[]> = new Map();\n\n  constructor(map: google.maps.Map) {\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n\n  async findPhotoWorthyRoutes(origin: string, destination: string): Promise<Route[]> {\n    try {\n      // Get routes for different travel modes in parallel\n      const travelModes = [\n        { mode: google.maps.TravelMode.WALKING, name: 'Walking' },\n        { mode: google.maps.TravelMode.BICYCLING, name: 'Cycling' },\n        { mode: google.maps.TravelMode.DRIVING, name: 'Driving' }\n      ];\n\n      const routePromises = travelModes.map(async (travelMode) => {\n        try {\n          const response = await this.getDirections(origin, destination, travelMode.mode);\n          return response.routes.map((route, index) => ({\n            route,\n            travelMode,\n            index\n          }));\n        } catch (error) {\n          console.warn(`Failed to get ${travelMode.name} routes:`, error);\n          return [];\n        }\n      });\n\n      const allRouteData = await Promise.all(routePromises);\n      const routes: Route[] = [];\n\n      // Process all routes in parallel\n      const routeProcessingPromises = allRouteData.flat().map(async ({ route, travelMode, index }) => {\n        const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n        const photoScore = this.calculateEnhancedPhotoScore(photoSpots, route);\n        const adjustedDuration = this.calculateAdjustedDuration(route, photoSpots);\n\n        return {\n          id: `route-${travelMode.name}-${index}`,\n          name: this.getRouteName(index, route, travelMode.name),\n          distance: route.legs[0].distance?.text || '',\n          duration: adjustedDuration,\n          photoScore,\n          photoSpots,\n          path: this.extractPathFromRoute(route),\n          travelMode: travelMode.name,\n          baseDuration: route.legs[0].duration?.text || ''\n        };\n      });\n\n      const processedRoutes = await Promise.all(routeProcessingPromises);\n      routes.push(...processedRoutes);\n\n      // Sort routes by photo score, then by duration for similar scores\n      return routes.sort((a, b) => {\n        if (Math.abs(a.photoScore - b.photoScore) < 10) {\n          // If photo scores are close, prefer shorter duration\n          return this.parseDuration(a.duration) - this.parseDuration(b.duration);\n        }\n        return b.photoScore - a.photoScore;\n      });\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n\n  private async getDirections(origin: string, destination: string, travelMode: google.maps.TravelMode): Promise<google.maps.DirectionsResult> {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route(\n        {\n          origin,\n          destination,\n          travelMode\n        },\n        (result, status) => {\n          if (status === google.maps.DirectionsStatus.OK && result) {\n            resolve(result);\n          } else {\n            reject(new Error(`Directions request failed: ${status}`));\n          }\n        }\n      );\n    });\n  }\n\n  private async findPhotoSpotsAlongRoute(route: google.maps.DirectionsRoute): Promise<PhotoSpot[]> {\n    const path = this.extractPathFromRoute(route);\n\n    // Sample fewer points for better performance\n    const numPoints = Math.min(Math.max(3, Math.floor(path.length / 20)), 8);\n    const samplePoints = this.getSamplePoints(path, numPoints);\n\n    // Search for photo spots in parallel\n    const spotPromises = samplePoints.map(point => this.searchNearbyPhotoSpots(point));\n    const spotsArrays = await Promise.all(spotPromises);\n    const photoSpots = spotsArrays.flat();\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n\n  private async searchNearbyPhotoSpots(location: { lat: number; lng: number }): Promise<PhotoSpot[]> {\n    const cacheKey = `${location.lat.toFixed(3)},${location.lng.toFixed(3)}`;\n\n    // Check cache first\n    if (this.photoSpotCache.has(cacheKey)) {\n      return this.photoSpotCache.get(cacheKey)!;\n    }\n\n    return new Promise((resolve) => {\n      this.placesService.nearbySearch(\n        {\n          location: new google.maps.LatLng(location.lat, location.lng),\n          radius: 200,\n          type: 'point_of_interest',\n          keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery|monument|statue|bridge|fountain|garden'\n        },\n        (results, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n            const photoSpots: PhotoSpot[] = results\n              .filter(place => place.rating && place.rating >= 3.5)\n              .map(place => ({\n                id: place.place_id || '',\n                name: place.name || '',\n                rating: place.rating || 0,\n                photoUrl: place.photos?.[0]?.getUrl({ maxWidth: 150, maxHeight: 100 }) ||\n                         `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n                distance: this.calculateDistance(location, { lat: place.geometry?.location?.lat() || 0, lng: place.geometry?.location?.lng() || 0 }),\n                location: {\n                  lat: place.geometry?.location?.lat() || 0,\n                  lng: place.geometry?.location?.lng() || 0\n                }\n              }));\n\n            // Cache the results\n            this.photoSpotCache.set(cacheKey, photoSpots);\n            resolve(photoSpots);\n          } else {\n            resolve([]);\n          }\n        }\n      );\n    });\n  }\n\n  private calculateEnhancedPhotoScore(photoSpots: PhotoSpot[], route: google.maps.DirectionsRoute): number {\n    if (photoSpots.length === 0) return 0;\n\n    const routeDistance = this.parseDistance(route.legs[0].distance?.text || '0 km');\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n\n    // Enhanced scoring algorithm\n    const ratingScore = Math.min(40, (avgRating - 3.0) * 20); // 0-40 points\n    const quantityScore = Math.min(30, photoSpots.length * 3); // 0-30 points\n\n    // Density bonus: more spots per km = higher score\n    const spotsPerKm = photoSpots.length / Math.max(routeDistance, 0.1);\n    const densityScore = Math.min(20, spotsPerKm * 5); // 0-20 points\n\n    // Variety bonus: different types of spots\n    const uniqueTypes = new Set(photoSpots.map(spot => this.getSpotType(spot.name))).size;\n    const varietyScore = Math.min(10, uniqueTypes * 2); // 0-10 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore + densityScore + varietyScore)));\n  }\n\n  private calculateAdjustedDuration(route: google.maps.DirectionsRoute, photoSpots: PhotoSpot[]): string {\n    const baseDuration = this.parseDuration(route.legs[0].duration?.text || '0 min');\n\n    // Add time for photo stops (5 minutes per photo spot)\n    const photoStopTime = photoSpots.length * 5;\n    const totalMinutes = baseDuration + photoStopTime;\n\n    return this.formatDuration(totalMinutes);\n  }\n\n  private parseDuration(durationText: string): number {\n    const match = durationText.match(/(\\d+)\\s*(?:hour|hr|h|minute|min|m)/i);\n    if (!match) return 0;\n\n    const value = parseInt(match[1]);\n    if (durationText.toLowerCase().includes('hour') || durationText.toLowerCase().includes('hr') || durationText.toLowerCase().includes('h')) {\n      return value * 60;\n    }\n    return value;\n  }\n\n  private parseDistance(distanceText: string): number {\n    const match = distanceText.match(/(\\d+(?:\\.\\d+)?)\\s*(?:km|mi|m)/i);\n    if (!match) return 0;\n\n    const value = parseFloat(match[1]);\n    if (distanceText.toLowerCase().includes('mi')) {\n      return value * 1.60934; // Convert miles to km\n    }\n    if (distanceText.toLowerCase().includes('m') && !distanceText.toLowerCase().includes('km')) {\n      return value / 1000; // Convert meters to km\n    }\n    return value;\n  }\n\n  private formatDuration(minutes: number): string {\n    if (minutes < 60) {\n      return `${minutes} min`;\n    }\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    if (remainingMinutes === 0) {\n      return `${hours} hour${hours > 1 ? 's' : ''}`;\n    }\n    return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} min`;\n  }\n\n  private getSpotType(name: string): string {\n    const lowerName = name.toLowerCase();\n    if (lowerName.includes('park') || lowerName.includes('garden')) return 'park';\n    if (lowerName.includes('museum') || lowerName.includes('gallery')) return 'museum';\n    if (lowerName.includes('cafe') || lowerName.includes('restaurant')) return 'cafe';\n    if (lowerName.includes('art') || lowerName.includes('mural')) return 'art';\n    if (lowerName.includes('bridge') || lowerName.includes('monument')) return 'landmark';\n    return 'other';\n  }\n\n  private extractPathFromRoute(route: google.maps.DirectionsRoute): Array<{ lat: number; lng: number }> {\n    const path: Array<{ lat: number; lng: number }> = [];\n\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({ lat: point.lat(), lng: point.lng() });\n          });\n        }\n      });\n    });\n\n    return path;\n  }\n\n  private getSamplePoints(path: Array<{ lat: number; lng: number }>, numPoints: number): Array<{ lat: number; lng: number }> {\n    if (path.length <= numPoints) return path;\n\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints: Array<{ lat: number; lng: number }> = [];\n\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n\n    return samplePoints;\n  }\n\n  private calculateDistance(point1: { lat: number; lng: number }, point2: { lat: number; lng: number }): string {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n\n  private deduplicatePhotoSpots(photoSpots: PhotoSpot[]): PhotoSpot[] {\n    const seen = new Set<string>();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n\n  private getRouteName(index: number, route: google.maps.DirectionsRoute, travelMode: string): string {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    const baseName = names[index] || `Route ${index + 1}`;\n    return `${baseName} (${travelMode})`;\n  }\n\n  // Clear cache when needed\n  clearCache(): void {\n    this.photoSpotCache.clear();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}