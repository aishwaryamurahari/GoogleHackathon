{"ast":null,"code":"export class RouteService {\n  constructor(map) {\n    this.directionsService = void 0;\n    this.placesService = void 0;\n    this.map = void 0;\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n  async findPhotoWorthyRoutes(origin, destination) {\n    try {\n      const routes = [];\n\n      // Get routes for different travel modes\n      const travelModes = [{\n        mode: google.maps.TravelMode.WALKING,\n        name: 'Walking'\n      }, {\n        mode: google.maps.TravelMode.BICYCLING,\n        name: 'Cycling'\n      }, {\n        mode: google.maps.TravelMode.DRIVING,\n        name: 'Driving'\n      }];\n      for (const travelMode of travelModes) {\n        try {\n          const response = await this.getDirections(origin, destination, travelMode.mode);\n          for (let i = 0; i < response.routes.length; i++) {\n            var _route$legs$0$distanc;\n            const route = response.routes[i];\n            const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n            const photoScore = this.calculateEnhancedPhotoScore(photoSpots, route);\n            const adjustedDuration = this.calculateAdjustedDuration(route, photoSpots);\n            routes.push({\n              id: `route-${travelMode.name}-${i}`,\n              name: this.getRouteName(i, route, travelMode.name),\n              distance: ((_route$legs$0$distanc = route.legs[0].distance) === null || _route$legs$0$distanc === void 0 ? void 0 : _route$legs$0$distanc.text) || '',\n              duration: adjustedDuration,\n              photoScore,\n              photoSpots,\n              path: this.extractPathFromRoute(route),\n              travelMode: travelMode.name\n            });\n          }\n        } catch (error) {\n          console.warn(`Failed to get ${travelMode.name} routes:`, error);\n        }\n      }\n\n      // Sort routes by photo score, then by duration for similar scores\n      return routes.sort((a, b) => {\n        if (Math.abs(a.photoScore - b.photoScore) < 10) {\n          // If photo scores are close, prefer shorter duration\n          return this.parseDuration(a.duration) - this.parseDuration(b.duration);\n        }\n        return b.photoScore - a.photoScore;\n      });\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n  async getDirections(origin, destination, travelMode) {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route({\n        origin,\n        destination,\n        travelMode,\n        alternatives: true // Get multiple route alternatives\n      }, (result, status) => {\n        if (status === google.maps.DirectionsStatus.OK && result) {\n          resolve(result);\n        } else {\n          reject(new Error(`Directions request failed: ${status}`));\n        }\n      });\n    });\n  }\n  async findPhotoSpotsAlongRoute(route) {\n    const photoSpots = [];\n    const path = this.extractPathFromRoute(route);\n\n    // Sample more points for longer routes\n    const numPoints = Math.min(Math.max(5, Math.floor(path.length / 10)), 15);\n    const samplePoints = this.getSamplePoints(path, numPoints);\n    for (const point of samplePoints) {\n      const spots = await this.searchNearbyPhotoSpots(point);\n      photoSpots.push(...spots);\n    }\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n  async searchNearbyPhotoSpots(location) {\n    return new Promise(resolve => {\n      this.placesService.nearbySearch({\n        location: new google.maps.LatLng(location.lat, location.lng),\n        radius: 200,\n        // Increased radius for better coverage\n        type: 'point_of_interest',\n        keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery|monument|statue|bridge|fountain|garden'\n      }, (results, status) => {\n        if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n          const photoSpots = results.filter(place => place.rating && place.rating >= 3.5) // Lowered threshold for more variety\n          .map(place => {\n            var _place$photos, _place$photos$, _place$geometry, _place$geometry$locat, _place$geometry2, _place$geometry2$loca, _place$geometry3, _place$geometry3$loca, _place$geometry4, _place$geometry4$loca;\n            return {\n              id: place.place_id || '',\n              name: place.name || '',\n              rating: place.rating || 0,\n              photoUrl: ((_place$photos = place.photos) === null || _place$photos === void 0 ? void 0 : (_place$photos$ = _place$photos[0]) === null || _place$photos$ === void 0 ? void 0 : _place$photos$.getUrl({\n                maxWidth: 150,\n                maxHeight: 100\n              })) || `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n              distance: this.calculateDistance(location, {\n                lat: ((_place$geometry = place.geometry) === null || _place$geometry === void 0 ? void 0 : (_place$geometry$locat = _place$geometry.location) === null || _place$geometry$locat === void 0 ? void 0 : _place$geometry$locat.lat()) || 0,\n                lng: ((_place$geometry2 = place.geometry) === null || _place$geometry2 === void 0 ? void 0 : (_place$geometry2$loca = _place$geometry2.location) === null || _place$geometry2$loca === void 0 ? void 0 : _place$geometry2$loca.lng()) || 0\n              }),\n              location: {\n                lat: ((_place$geometry3 = place.geometry) === null || _place$geometry3 === void 0 ? void 0 : (_place$geometry3$loca = _place$geometry3.location) === null || _place$geometry3$loca === void 0 ? void 0 : _place$geometry3$loca.lat()) || 0,\n                lng: ((_place$geometry4 = place.geometry) === null || _place$geometry4 === void 0 ? void 0 : (_place$geometry4$loca = _place$geometry4.location) === null || _place$geometry4$loca === void 0 ? void 0 : _place$geometry4$loca.lng()) || 0\n              }\n            };\n          });\n          resolve(photoSpots);\n        } else {\n          resolve([]);\n        }\n      });\n    });\n  }\n  calculateEnhancedPhotoScore(photoSpots, route) {\n    var _route$legs$0$distanc2;\n    if (photoSpots.length === 0) return 0;\n    const routeDistance = this.parseDistance(((_route$legs$0$distanc2 = route.legs[0].distance) === null || _route$legs$0$distanc2 === void 0 ? void 0 : _route$legs$0$distanc2.text) || '0 km');\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n\n    // Enhanced scoring algorithm\n    const ratingScore = Math.min(40, (avgRating - 3.0) * 20); // 0-40 points\n    const quantityScore = Math.min(30, photoSpots.length * 3); // 0-30 points\n\n    // Density bonus: more spots per km = higher score\n    const spotsPerKm = photoSpots.length / Math.max(routeDistance, 0.1);\n    const densityScore = Math.min(20, spotsPerKm * 5); // 0-20 points\n\n    // Variety bonus: different types of spots\n    const uniqueTypes = new Set(photoSpots.map(spot => this.getSpotType(spot.name))).size;\n    const varietyScore = Math.min(10, uniqueTypes * 2); // 0-10 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore + densityScore + varietyScore)));\n  }\n  calculateAdjustedDuration(route, photoSpots) {\n    var _route$legs$0$duratio;\n    const baseDuration = this.parseDuration(((_route$legs$0$duratio = route.legs[0].duration) === null || _route$legs$0$duratio === void 0 ? void 0 : _route$legs$0$duratio.text) || '0 min');\n\n    // Add time for photo stops (5 minutes per photo spot)\n    const photoStopTime = photoSpots.length * 5;\n    const totalMinutes = baseDuration + photoStopTime;\n    return this.formatDuration(totalMinutes);\n  }\n  parseDuration(durationText) {\n    const match = durationText.match(/(\\d+)\\s*(?:hour|hr|h|minute|min|m)/i);\n    if (!match) return 0;\n    const value = parseInt(match[1]);\n    if (durationText.toLowerCase().includes('hour') || durationText.toLowerCase().includes('hr') || durationText.toLowerCase().includes('h')) {\n      return value * 60;\n    }\n    return value;\n  }\n  parseDistance(distanceText) {\n    const match = distanceText.match(/(\\d+(?:\\.\\d+)?)\\s*(?:km|mi|m)/i);\n    if (!match) return 0;\n    const value = parseFloat(match[1]);\n    if (distanceText.toLowerCase().includes('mi')) {\n      return value * 1.60934; // Convert miles to km\n    }\n    if (distanceText.toLowerCase().includes('m') && !distanceText.toLowerCase().includes('km')) {\n      return value / 1000; // Convert meters to km\n    }\n    return value;\n  }\n  formatDuration(minutes) {\n    if (minutes < 60) {\n      return `${minutes} min`;\n    }\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    if (remainingMinutes === 0) {\n      return `${hours} hour${hours > 1 ? 's' : ''}`;\n    }\n    return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} min`;\n  }\n  getSpotType(name) {\n    const lowerName = name.toLowerCase();\n    if (lowerName.includes('park') || lowerName.includes('garden')) return 'park';\n    if (lowerName.includes('museum') || lowerName.includes('gallery')) return 'museum';\n    if (lowerName.includes('cafe') || lowerName.includes('restaurant')) return 'cafe';\n    if (lowerName.includes('art') || lowerName.includes('mural')) return 'art';\n    if (lowerName.includes('bridge') || lowerName.includes('monument')) return 'landmark';\n    return 'other';\n  }\n  extractPathFromRoute(route) {\n    const path = [];\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({\n              lat: point.lat(),\n              lng: point.lng()\n            });\n          });\n        }\n      });\n    });\n    return path;\n  }\n  getSamplePoints(path, numPoints) {\n    if (path.length <= numPoints) return path;\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints = [];\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n    return samplePoints;\n  }\n  calculateDistance(point1, point2) {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n  deduplicatePhotoSpots(photoSpots) {\n    const seen = new Set();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n  getRouteName(index, route, travelMode) {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    const baseName = names[index] || `Route ${index + 1}`;\n    return `${baseName} (${travelMode})`;\n  }\n}","map":{"version":3,"names":["RouteService","constructor","map","directionsService","placesService","google","maps","DirectionsService","places","PlacesService","findPhotoWorthyRoutes","origin","destination","routes","travelModes","mode","TravelMode","WALKING","name","BICYCLING","DRIVING","travelMode","response","getDirections","i","length","_route$legs$0$distanc","route","photoSpots","findPhotoSpotsAlongRoute","photoScore","calculateEnhancedPhotoScore","adjustedDuration","calculateAdjustedDuration","push","id","getRouteName","distance","legs","text","duration","path","extractPathFromRoute","error","console","warn","sort","a","b","Math","abs","parseDuration","Promise","resolve","reject","alternatives","result","status","DirectionsStatus","OK","Error","numPoints","min","max","floor","samplePoints","getSamplePoints","point","spots","searchNearbyPhotoSpots","deduplicatePhotoSpots","rating","location","nearbySearch","LatLng","lat","lng","radius","type","keyword","results","PlacesServiceStatus","filter","place","_place$photos","_place$photos$","_place$geometry","_place$geometry$locat","_place$geometry2","_place$geometry2$loca","_place$geometry3","_place$geometry3$loca","_place$geometry4","_place$geometry4$loca","place_id","photoUrl","photos","getUrl","maxWidth","maxHeight","encodeURIComponent","calculateDistance","geometry","_route$legs$0$distanc2","routeDistance","parseDistance","avgRating","reduce","sum","spot","ratingScore","quantityScore","spotsPerKm","densityScore","uniqueTypes","Set","getSpotType","size","varietyScore","round","_route$legs$0$duratio","baseDuration","photoStopTime","totalMinutes","formatDuration","durationText","match","value","parseInt","toLowerCase","includes","distanceText","parseFloat","minutes","hours","remainingMinutes","lowerName","forEach","leg","steps","step","index","point1","point2","R","dLat","PI","dLng","sin","cos","c","atan2","sqrt","toFixed","seen","has","add","names","baseName"],"sources":["/Users/aishwaryamurahari/Documents/study/GoogleHackathon/src/services/routeService.ts"],"sourcesContent":["import { Route, PhotoSpot } from '../types';\n\ndeclare global {\n  interface Window {\n    google: typeof google;\n  }\n}\n\nexport class RouteService {\n  private directionsService: google.maps.DirectionsService;\n  private placesService: google.maps.places.PlacesService;\n  private map: google.maps.Map;\n\n  constructor(map: google.maps.Map) {\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n\n  async findPhotoWorthyRoutes(origin: string, destination: string): Promise<Route[]> {\n    try {\n      const routes: Route[] = [];\n\n      // Get routes for different travel modes\n      const travelModes = [\n        { mode: google.maps.TravelMode.WALKING, name: 'Walking' },\n        { mode: google.maps.TravelMode.BICYCLING, name: 'Cycling' },\n        { mode: google.maps.TravelMode.DRIVING, name: 'Driving' }\n      ];\n\n      for (const travelMode of travelModes) {\n        try {\n          const response = await this.getDirections(origin, destination, travelMode.mode);\n\n          for (let i = 0; i < response.routes.length; i++) {\n            const route = response.routes[i];\n            const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n            const photoScore = this.calculateEnhancedPhotoScore(photoSpots, route);\n            const adjustedDuration = this.calculateAdjustedDuration(route, photoSpots);\n\n            routes.push({\n              id: `route-${travelMode.name}-${i}`,\n              name: this.getRouteName(i, route, travelMode.name),\n              distance: route.legs[0].distance?.text || '',\n              duration: adjustedDuration,\n              photoScore,\n              photoSpots,\n              path: this.extractPathFromRoute(route),\n              travelMode: travelMode.name\n            });\n          }\n        } catch (error) {\n          console.warn(`Failed to get ${travelMode.name} routes:`, error);\n        }\n      }\n\n      // Sort routes by photo score, then by duration for similar scores\n      return routes.sort((a, b) => {\n        if (Math.abs(a.photoScore - b.photoScore) < 10) {\n          // If photo scores are close, prefer shorter duration\n          return this.parseDuration(a.duration) - this.parseDuration(b.duration);\n        }\n        return b.photoScore - a.photoScore;\n      });\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n\n  private async getDirections(origin: string, destination: string, travelMode: google.maps.TravelMode): Promise<google.maps.DirectionsResult> {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route(\n        {\n          origin,\n          destination,\n          travelMode,\n          alternatives: true // Get multiple route alternatives\n        },\n        (result, status) => {\n          if (status === google.maps.DirectionsStatus.OK && result) {\n            resolve(result);\n          } else {\n            reject(new Error(`Directions request failed: ${status}`));\n          }\n        }\n      );\n    });\n  }\n\n  private async findPhotoSpotsAlongRoute(route: google.maps.DirectionsRoute): Promise<PhotoSpot[]> {\n    const photoSpots: PhotoSpot[] = [];\n    const path = this.extractPathFromRoute(route);\n\n    // Sample more points for longer routes\n    const numPoints = Math.min(Math.max(5, Math.floor(path.length / 10)), 15);\n    const samplePoints = this.getSamplePoints(path, numPoints);\n\n    for (const point of samplePoints) {\n      const spots = await this.searchNearbyPhotoSpots(point);\n      photoSpots.push(...spots);\n    }\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n\n  private async searchNearbyPhotoSpots(location: { lat: number; lng: number }): Promise<PhotoSpot[]> {\n    return new Promise((resolve) => {\n      this.placesService.nearbySearch(\n        {\n          location: new google.maps.LatLng(location.lat, location.lng),\n          radius: 200, // Increased radius for better coverage\n          type: 'point_of_interest',\n          keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery|monument|statue|bridge|fountain|garden'\n        },\n        (results, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n            const photoSpots: PhotoSpot[] = results\n              .filter(place => place.rating && place.rating >= 3.5) // Lowered threshold for more variety\n              .map(place => ({\n                id: place.place_id || '',\n                name: place.name || '',\n                rating: place.rating || 0,\n                photoUrl: place.photos?.[0]?.getUrl({ maxWidth: 150, maxHeight: 100 }) ||\n                         `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n                distance: this.calculateDistance(location, { lat: place.geometry?.location?.lat() || 0, lng: place.geometry?.location?.lng() || 0 }),\n                location: {\n                  lat: place.geometry?.location?.lat() || 0,\n                  lng: place.geometry?.location?.lng() || 0\n                }\n              }));\n            resolve(photoSpots);\n          } else {\n            resolve([]);\n          }\n        }\n      );\n    });\n  }\n\n  private calculateEnhancedPhotoScore(photoSpots: PhotoSpot[], route: google.maps.DirectionsRoute): number {\n    if (photoSpots.length === 0) return 0;\n\n    const routeDistance = this.parseDistance(route.legs[0].distance?.text || '0 km');\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n\n    // Enhanced scoring algorithm\n    const ratingScore = Math.min(40, (avgRating - 3.0) * 20); // 0-40 points\n    const quantityScore = Math.min(30, photoSpots.length * 3); // 0-30 points\n\n    // Density bonus: more spots per km = higher score\n    const spotsPerKm = photoSpots.length / Math.max(routeDistance, 0.1);\n    const densityScore = Math.min(20, spotsPerKm * 5); // 0-20 points\n\n    // Variety bonus: different types of spots\n    const uniqueTypes = new Set(photoSpots.map(spot => this.getSpotType(spot.name))).size;\n    const varietyScore = Math.min(10, uniqueTypes * 2); // 0-10 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore + densityScore + varietyScore)));\n  }\n\n  private calculateAdjustedDuration(route: google.maps.DirectionsRoute, photoSpots: PhotoSpot[]): string {\n    const baseDuration = this.parseDuration(route.legs[0].duration?.text || '0 min');\n\n    // Add time for photo stops (5 minutes per photo spot)\n    const photoStopTime = photoSpots.length * 5;\n    const totalMinutes = baseDuration + photoStopTime;\n\n    return this.formatDuration(totalMinutes);\n  }\n\n  private parseDuration(durationText: string): number {\n    const match = durationText.match(/(\\d+)\\s*(?:hour|hr|h|minute|min|m)/i);\n    if (!match) return 0;\n\n    const value = parseInt(match[1]);\n    if (durationText.toLowerCase().includes('hour') || durationText.toLowerCase().includes('hr') || durationText.toLowerCase().includes('h')) {\n      return value * 60;\n    }\n    return value;\n  }\n\n  private parseDistance(distanceText: string): number {\n    const match = distanceText.match(/(\\d+(?:\\.\\d+)?)\\s*(?:km|mi|m)/i);\n    if (!match) return 0;\n\n    const value = parseFloat(match[1]);\n    if (distanceText.toLowerCase().includes('mi')) {\n      return value * 1.60934; // Convert miles to km\n    }\n    if (distanceText.toLowerCase().includes('m') && !distanceText.toLowerCase().includes('km')) {\n      return value / 1000; // Convert meters to km\n    }\n    return value;\n  }\n\n  private formatDuration(minutes: number): string {\n    if (minutes < 60) {\n      return `${minutes} min`;\n    }\n    const hours = Math.floor(minutes / 60);\n    const remainingMinutes = minutes % 60;\n    if (remainingMinutes === 0) {\n      return `${hours} hour${hours > 1 ? 's' : ''}`;\n    }\n    return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} min`;\n  }\n\n  private getSpotType(name: string): string {\n    const lowerName = name.toLowerCase();\n    if (lowerName.includes('park') || lowerName.includes('garden')) return 'park';\n    if (lowerName.includes('museum') || lowerName.includes('gallery')) return 'museum';\n    if (lowerName.includes('cafe') || lowerName.includes('restaurant')) return 'cafe';\n    if (lowerName.includes('art') || lowerName.includes('mural')) return 'art';\n    if (lowerName.includes('bridge') || lowerName.includes('monument')) return 'landmark';\n    return 'other';\n  }\n\n  private extractPathFromRoute(route: google.maps.DirectionsRoute): Array<{ lat: number; lng: number }> {\n    const path: Array<{ lat: number; lng: number }> = [];\n\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({ lat: point.lat(), lng: point.lng() });\n          });\n        }\n      });\n    });\n\n    return path;\n  }\n\n  private getSamplePoints(path: Array<{ lat: number; lng: number }>, numPoints: number): Array<{ lat: number; lng: number }> {\n    if (path.length <= numPoints) return path;\n\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints: Array<{ lat: number; lng: number }> = [];\n\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n\n    return samplePoints;\n  }\n\n  private calculateDistance(point1: { lat: number; lng: number }, point2: { lat: number; lng: number }): string {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n\n  private deduplicatePhotoSpots(photoSpots: PhotoSpot[]): PhotoSpot[] {\n    const seen = new Set<string>();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n\n  private getRouteName(index: number, route: google.maps.DirectionsRoute, travelMode: string): string {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    const baseName = names[index] || `Route ${index + 1}`;\n    return `${baseName} (${travelMode})`;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}