{"ast":null,"code":"export class RouteService {\n  constructor(map) {\n    this.directionsService = void 0;\n    this.placesService = void 0;\n    this.map = void 0;\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n  async findPhotoWorthyRoutes(origin, destination) {\n    try {\n      // Get multiple route alternatives\n      const response = await this.getDirections(origin, destination);\n      const routes = [];\n      for (let i = 0; i < response.routes.length; i++) {\n        var _route$legs$0$distanc, _route$legs$0$duratio;\n        const route = response.routes[i];\n        const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n        const photoScore = this.calculatePhotoScore(photoSpots);\n        routes.push({\n          id: `route-${i}`,\n          name: this.getRouteName(i, route),\n          distance: ((_route$legs$0$distanc = route.legs[0].distance) === null || _route$legs$0$distanc === void 0 ? void 0 : _route$legs$0$distanc.text) || '',\n          duration: ((_route$legs$0$duratio = route.legs[0].duration) === null || _route$legs$0$duratio === void 0 ? void 0 : _route$legs$0$duratio.text) || '',\n          photoScore,\n          photoSpots,\n          path: this.extractPathFromRoute(route)\n        });\n      }\n\n      // Sort routes by photo score\n      return routes.sort((a, b) => b.photoScore - a.photoScore);\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n  async getDirections(origin, destination) {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route({\n        origin,\n        destination,\n        travelMode: google.maps.TravelMode.WALKING\n      }, (result, status) => {\n        if (status === google.maps.DirectionsStatus.OK && result) {\n          resolve(result);\n        } else {\n          reject(new Error(`Directions request failed: ${status}`));\n        }\n      });\n    });\n  }\n  async findPhotoSpotsAlongRoute(route) {\n    const photoSpots = [];\n    const path = this.extractPathFromRoute(route);\n\n    // Sample points along the route to search for POIs\n    const samplePoints = this.getSamplePoints(path, 5);\n    for (const point of samplePoints) {\n      const spots = await this.searchNearbyPhotoSpots(point);\n      photoSpots.push(...spots);\n    }\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n  async searchNearbyPhotoSpots(location) {\n    return new Promise(resolve => {\n      this.placesService.nearbySearch({\n        location: new google.maps.LatLng(location.lat, location.lng),\n        radius: 100,\n        // 100 meters\n        type: 'point_of_interest',\n        keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery'\n      }, (results, status) => {\n        if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n          const photoSpots = results.filter(place => place.rating && place.rating >= 4.0) // Only highly-rated places\n          .map(place => {\n            var _place$photos, _place$photos$, _place$geometry, _place$geometry$locat, _place$geometry2, _place$geometry2$loca, _place$geometry3, _place$geometry3$loca, _place$geometry4, _place$geometry4$loca;\n            return {\n              id: place.place_id || '',\n              name: place.name || '',\n              rating: place.rating || 0,\n              photoUrl: ((_place$photos = place.photos) === null || _place$photos === void 0 ? void 0 : (_place$photos$ = _place$photos[0]) === null || _place$photos$ === void 0 ? void 0 : _place$photos$.getUrl({\n                maxWidth: 150,\n                maxHeight: 100\n              })) || `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n              distance: this.calculateDistance(location, {\n                lat: ((_place$geometry = place.geometry) === null || _place$geometry === void 0 ? void 0 : (_place$geometry$locat = _place$geometry.location) === null || _place$geometry$locat === void 0 ? void 0 : _place$geometry$locat.lat()) || 0,\n                lng: ((_place$geometry2 = place.geometry) === null || _place$geometry2 === void 0 ? void 0 : (_place$geometry2$loca = _place$geometry2.location) === null || _place$geometry2$loca === void 0 ? void 0 : _place$geometry2$loca.lng()) || 0\n              }),\n              location: {\n                lat: ((_place$geometry3 = place.geometry) === null || _place$geometry3 === void 0 ? void 0 : (_place$geometry3$loca = _place$geometry3.location) === null || _place$geometry3$loca === void 0 ? void 0 : _place$geometry3$loca.lat()) || 0,\n                lng: ((_place$geometry4 = place.geometry) === null || _place$geometry4 === void 0 ? void 0 : (_place$geometry4$loca = _place$geometry4.location) === null || _place$geometry4$loca === void 0 ? void 0 : _place$geometry4$loca.lng()) || 0\n              }\n            };\n          });\n          resolve(photoSpots);\n        } else {\n          resolve([]);\n        }\n      });\n    });\n  }\n  calculatePhotoScore(photoSpots) {\n    if (photoSpots.length === 0) return 0;\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n    const numSpots = Math.min(photoSpots.length, 10); // Cap at 10 spots for scoring\n\n    // Score based on number of spots and average rating\n    const ratingScore = (avgRating - 3.0) * 20; // 0-40 points\n    const quantityScore = numSpots * 6; // 0-60 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore)));\n  }\n  extractPathFromRoute(route) {\n    const path = [];\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({\n              lat: point.lat(),\n              lng: point.lng()\n            });\n          });\n        }\n      });\n    });\n    return path;\n  }\n  getSamplePoints(path, numPoints) {\n    if (path.length <= numPoints) return path;\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints = [];\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n    return samplePoints;\n  }\n  calculateDistance(point1, point2) {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n  deduplicatePhotoSpots(photoSpots) {\n    const seen = new Set();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n  getRouteName(index, route) {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    return names[index] || `Route ${index + 1}`;\n  }\n}","map":{"version":3,"names":["RouteService","constructor","map","directionsService","placesService","google","maps","DirectionsService","places","PlacesService","findPhotoWorthyRoutes","origin","destination","response","getDirections","routes","i","length","_route$legs$0$distanc","_route$legs$0$duratio","route","photoSpots","findPhotoSpotsAlongRoute","photoScore","calculatePhotoScore","push","id","name","getRouteName","distance","legs","text","duration","path","extractPathFromRoute","sort","a","b","error","console","Promise","resolve","reject","travelMode","TravelMode","WALKING","result","status","DirectionsStatus","OK","Error","samplePoints","getSamplePoints","point","spots","searchNearbyPhotoSpots","deduplicatePhotoSpots","rating","location","nearbySearch","LatLng","lat","lng","radius","type","keyword","results","PlacesServiceStatus","filter","place","_place$photos","_place$photos$","_place$geometry","_place$geometry$locat","_place$geometry2","_place$geometry2$loca","_place$geometry3","_place$geometry3$loca","_place$geometry4","_place$geometry4$loca","place_id","photoUrl","photos","getUrl","maxWidth","maxHeight","encodeURIComponent","calculateDistance","geometry","avgRating","reduce","sum","spot","numSpots","Math","min","ratingScore","quantityScore","max","round","forEach","leg","steps","step","numPoints","floor","index","point1","point2","R","dLat","PI","dLng","sin","cos","c","atan2","sqrt","toFixed","seen","Set","has","add","names"],"sources":["/Users/aishwaryamurahari/Documents/study/GoogleHackathon/src/services/routeService.ts"],"sourcesContent":["import { Route, PhotoSpot } from '../types';\n\ndeclare global {\n  interface Window {\n    google: typeof google;\n  }\n}\n\nexport class RouteService {\n  private directionsService: google.maps.DirectionsService;\n  private placesService: google.maps.places.PlacesService;\n  private map: google.maps.Map;\n\n  constructor(map: google.maps.Map) {\n    this.map = map;\n    this.directionsService = new google.maps.DirectionsService();\n    this.placesService = new google.maps.places.PlacesService(map);\n  }\n\n  async findPhotoWorthyRoutes(origin: string, destination: string): Promise<Route[]> {\n    try {\n      // Get multiple route alternatives\n      const response = await this.getDirections(origin, destination);\n      const routes: Route[] = [];\n\n      for (let i = 0; i < response.routes.length; i++) {\n        const route = response.routes[i];\n        const photoSpots = await this.findPhotoSpotsAlongRoute(route);\n        const photoScore = this.calculatePhotoScore(photoSpots);\n\n        routes.push({\n          id: `route-${i}`,\n          name: this.getRouteName(i, route),\n          distance: route.legs[0].distance?.text || '',\n          duration: route.legs[0].duration?.text || '',\n          photoScore,\n          photoSpots,\n          path: this.extractPathFromRoute(route)\n        });\n      }\n\n      // Sort routes by photo score\n      return routes.sort((a, b) => b.photoScore - a.photoScore);\n    } catch (error) {\n      console.error('Error finding routes:', error);\n      throw error;\n    }\n  }\n\n  private async getDirections(origin: string, destination: string): Promise<google.maps.DirectionsResult> {\n    return new Promise((resolve, reject) => {\n      this.directionsService.route(\n        {\n          origin,\n          destination,\n          travelMode: google.maps.TravelMode.WALKING\n        },\n        (result, status) => {\n          if (status === google.maps.DirectionsStatus.OK && result) {\n            resolve(result);\n          } else {\n            reject(new Error(`Directions request failed: ${status}`));\n          }\n        }\n      );\n    });\n  }\n\n  private async findPhotoSpotsAlongRoute(route: google.maps.DirectionsRoute): Promise<PhotoSpot[]> {\n    const photoSpots: PhotoSpot[] = [];\n    const path = this.extractPathFromRoute(route);\n\n    // Sample points along the route to search for POIs\n    const samplePoints = this.getSamplePoints(path, 5);\n\n    for (const point of samplePoints) {\n      const spots = await this.searchNearbyPhotoSpots(point);\n      photoSpots.push(...spots);\n    }\n\n    // Remove duplicates and sort by rating\n    return this.deduplicatePhotoSpots(photoSpots).sort((a, b) => b.rating - a.rating);\n  }\n\n  private async searchNearbyPhotoSpots(location: { lat: number; lng: number }): Promise<PhotoSpot[]> {\n    return new Promise((resolve) => {\n      this.placesService.nearbySearch(\n        {\n          location: new google.maps.LatLng(location.lat, location.lng),\n          radius: 100, // 100 meters\n          type: 'point_of_interest',\n          keyword: 'photo|scenic|landmark|art|mural|cafe|park|view|museum|gallery'\n        },\n        (results, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n            const photoSpots: PhotoSpot[] = results\n              .filter(place => place.rating && place.rating >= 4.0) // Only highly-rated places\n              .map(place => ({\n                id: place.place_id || '',\n                name: place.name || '',\n                rating: place.rating || 0,\n                photoUrl: place.photos?.[0]?.getUrl({ maxWidth: 150, maxHeight: 100 }) ||\n                         `https://via.placeholder.com/150x100/4ECDC4/FFFFFF?text=${encodeURIComponent(place.name || '')}`,\n                distance: this.calculateDistance(location, { lat: place.geometry?.location?.lat() || 0, lng: place.geometry?.location?.lng() || 0 }),\n                location: {\n                  lat: place.geometry?.location?.lat() || 0,\n                  lng: place.geometry?.location?.lng() || 0\n                }\n              }));\n            resolve(photoSpots);\n          } else {\n            resolve([]);\n          }\n        }\n      );\n    });\n  }\n\n  private calculatePhotoScore(photoSpots: PhotoSpot[]): number {\n    if (photoSpots.length === 0) return 0;\n\n    const avgRating = photoSpots.reduce((sum, spot) => sum + spot.rating, 0) / photoSpots.length;\n    const numSpots = Math.min(photoSpots.length, 10); // Cap at 10 spots for scoring\n\n    // Score based on number of spots and average rating\n    const ratingScore = (avgRating - 3.0) * 20; // 0-40 points\n    const quantityScore = numSpots * 6; // 0-60 points\n\n    return Math.min(100, Math.max(0, Math.round(ratingScore + quantityScore)));\n  }\n\n  private extractPathFromRoute(route: google.maps.DirectionsRoute): Array<{ lat: number; lng: number }> {\n    const path: Array<{ lat: number; lng: number }> = [];\n\n    route.legs.forEach(leg => {\n      leg.steps.forEach(step => {\n        if (step.path) {\n          step.path.forEach(point => {\n            path.push({ lat: point.lat(), lng: point.lng() });\n          });\n        }\n      });\n    });\n\n    return path;\n  }\n\n  private getSamplePoints(path: Array<{ lat: number; lng: number }>, numPoints: number): Array<{ lat: number; lng: number }> {\n    if (path.length <= numPoints) return path;\n\n    const step = Math.floor(path.length / numPoints);\n    const samplePoints: Array<{ lat: number; lng: number }> = [];\n\n    for (let i = 0; i < numPoints; i++) {\n      const index = i * step;\n      samplePoints.push(path[index]);\n    }\n\n    return samplePoints;\n  }\n\n  private calculateDistance(point1: { lat: number; lng: number }, point2: { lat: number; lng: number }): string {\n    const R = 6371; // Earth's radius in km\n    const dLat = (point2.lat - point1.lat) * Math.PI / 180;\n    const dLng = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Convert to meters\n\n    if (distance < 1000) {\n      return `${Math.round(distance)}m`;\n    } else {\n      return `${(distance / 1000).toFixed(1)}km`;\n    }\n  }\n\n  private deduplicatePhotoSpots(photoSpots: PhotoSpot[]): PhotoSpot[] {\n    const seen = new Set<string>();\n    return photoSpots.filter(spot => {\n      if (seen.has(spot.id)) return false;\n      seen.add(spot.id);\n      return true;\n    });\n  }\n\n  private getRouteName(index: number, route: google.maps.DirectionsRoute): string {\n    const names = ['Scenic Route', 'Cultural Path', 'Art Walk', 'Historic Trail', 'Photo Route'];\n    return names[index] || `Route ${index + 1}`;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}